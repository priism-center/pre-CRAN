---
title: "BiasAmp Code to Replicate Obs. Studies (2018) paper"
author: Marc Scott
output: md_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# IEA International Obs Study in which the "treatment" is a family characteristic (# books in home) regressed on reading comprehension score 

# In terms of our modeling paradogm, the variables are (numbers in parenthesis indicate location in original IEA file):
# Y: reading comprehension test raw score (608)
# G: different schools (3)
# Z: number of books in home (178)
# X: sex (165),hours of homework (167), word knowledge raw score (247)
# W: Z.groupmean,X.groupmean,size of the school (25,26),type of community served (18)

# depends:
#  biasAmpR_v2r3.R
#
# data source:
#  IEA.RData (preprocessed dataset)

library(foreign)
library(dplyr)
library(plyr)
library(reshape)
library(nlme)
library(lme4)
library(arm)
library(lattice)

#read support fns
if (!exists('runModels')) source("biasAmpR_v2r3.R")
#read data
if (!exists('scotland')) load("ObsStudies_IEA.RData")
```

# run lmer and lm models

This is a script that produces model results for the ObsStudies paper. Plots follow model runs.


```{r 1}
#chose country names
#each name corresponds to a dataframe object in ObsStudies_IEA.RData 

cnames <-c("scotland","sweden","italy")

```

## Data Setup first
## Common formulas set up
## Then run models, all in a loop one for each country selected.

```{r 2}

set.seed(12341)
for (ii in 1:length(cnames)) {
    
  country <- get(cnames[ii])

  #BETWEEN ##### could be a class to a 'helper' function called IEApreprocess that takes logs, removes NAs, etc.
  ################################
  country$pop <- log(country$pop)  #transform towards symmetry
  country$pop[is.infinite(country$pop)] <- NA
  
  country$type <- factor(country$type)
  
  #remove NAs:
  cdat <- model.frame(score~num_books + sex + word_knowl + homework + type + pop + school,data=country) #should remove NAs

  #set up indicator vars for factors:
  cdat$type0 <- 1*(cdat$type==0)
  cdat$type1 <- 1*(cdat$type==1)
  cdat$type2 <- 1*(cdat$type==2)
  cdat$type3 <- 1*(cdat$type==3)
  cdat$type4 <- 1*(cdat$type==4)
  cdat$type5 <- 1*(cdat$type==5)
  cdat$type6 <- 1*(cdat$type==6)
  ##################################
  
  nPerSchool <- mean(table(cdat$school))
  nPerSchool <- prod(table(cdat$school))^(1/length(unique(cdat$school))) # works better with geo-mean
  
  ## Prepare the formulas for the model fit calls.  -- make a helper fnc.
  ## 
  ##################################
  #indiv preds
  fmlaX <- ~sex + word_knowl + homework
  #group var preds

  fmlaW.str <- "~pop"
  first <- TRUE # flag
  for (i in 0:6) {# add only types with variation
      tstr <- paste("type",as.character(i),collapse="",sep="")
      len <- length(table(cdat[,tstr]))
      if (len>1) {
           if (!first) fmlaW.str <- paste(fmlaW.str,tstr,collapse="",sep="+")
           first <- FALSE # ensures ref category
      }
  }
  fmlaW <- as.formula(fmlaW.str)
  #set treatment
  fmlaZ <- ~num_books
  fmlaY <- ~score
  ####################################
  
  
  #fit models
  mdl.fit <- runModels(outcome=fmlaY, treatment=fmlaZ, level1.pred = fmlaX, level2.pred = fmlaW, group = ~school, data=cdat)
  
  ## Make a helper function out of below that's a PRINT method, basically, taking mdl.fit as the main argument.
  ##
  ################################
  #extract variance comps & some bias diffs
  pObj <- extractParams(mdl.fit)
  #for ObsStudies paper:
  print(cnames[ii])
  print(summary(mdl.fit$mlm1.y))
  print(summary(mdl.fit$ols1.y))
  print(paste("Table 1 for: ",cnames[ii]))
  rsltTab1 <- rbind(cbind(pObj$tau.w,pObj$tau.b,pObj$tau.ols),pObj$bias.diffs)
  dimnames(rsltTab1) <- list(c("tau0","tau1","diff"),c("Within","Between","OLS"))
  print(round(rsltTab1,2))
  print(round(as.vector(t(cbind(pObj$sigs,pObj$sigs[,2]/apply(pObj$sigs,1,sum)))),2))
  print(round(cbind(pObj$sigs,pObj$sigs[,2]/apply(pObj$sigs,1,sum)),2))
  print(paste("gy,vy,t.gz ",paste(round(sqrt(c(pObj$gy.vw.gy,pObj$sds.y.ucm$sd.alpha.y.ucm^2,2^2*pObj$gz.vw.gz)),3),collapse=", "),sep=" "))
  ####################################

  
  ## helper function for the condition number of matrix used in the model - call, print, and move on.
  ## possible that we need some of the params generated here going forward.  Check.
  ##
  ################################
  parms <- c("zeta","delta","beta","gamma")
  paramIdx <- 4
  paramCh <- parms[paramIdx]
  
  rescaleParms <- c(1,1)
  bnd.f <- makeBnds(pObj,param=paramCh)

  recovParms4 <- recovParms <- recover(pObj,varyParm=paramCh,bnd.f,nParm=201,tau.max=1, gpSize=nPerSchool)  # corresponds to the bound when 'gamma' (parm 4) is the open param.

  cat("cond num=",recovParms$condNum,"\n")
  ####################################

  #FIND THE RIGHT 4th Param from the 3rd param beta-based value for eta...
  recovParms3<-recover(pObj,varyParm="beta",makeBnds(pObj,param="beta"),nParm=201,tau.max=1,gpSize=nPerSchool)  # corresponds to the bound when 'beta' (parm 3) is the open param.
  
  #there is a gamma corresp. to this beta
  gamma.at.beta <- recovParms3$zetaDeltaMat[which.min(abs(recovParms3$zetaDeltaMat[,3]-pObj$by.vx.bz)),4]
  
  #get other 'target' values:
  nu.at.zeta.0 <- recovParms$zetaDeltaMat[which.min(abs(recovParms$zetaDeltaMat[,1])),paramIdx]
  nu.at.delta.0 <- recovParms$zetaDeltaMat[which.min(abs(recovParms$zetaDeltaMat[,2])),paramIdx]
  
  #reduce range if info from Beta warrants it
  nu.g.min <- min(recovParms3$zetaDeltaMat[,4])
  nu.g.max <- max(recovParms3$zetaDeltaMat[,4])
  #fix range here
  b.in.range <- recovParms4$zetaDeltaMat[,4] >= nu.g.min & recovParms4$zetaDeltaMat[,4] <= nu.g.max
  recovParms$zetaDeltaMat <- recovParms$zetaDeltaMat[b.in.range,]
  recovParms$parmRange <- recovParms$parmRange[b.in.range]
  recovParms$plausible.taus <- recovParms$plausible.taus[b.in.range]


  #plot params set for .png inlcuded in LaTeX file; adjust as nec.
  lcex <- 3
  pcex <- 2
  png(paste(cnames[ii],"png",sep=".",collapse=""),width=pcex*480,height=pcex*480)
  tvals <- c(gamma.at.beta,pObj$gy.vw.gz,nu.at.zeta.0,nu.at.delta.0)
  tpch <- c(0,4,1,3)
  taus <- list(ols=pObj$tau.ols[2],win=pObj$tau.w[2])
  confPts <- NULL #default
  
  print("target for nu(by.vx.bz): ")
  print(nu.at.zeta.0)
  
  plot(zdPlot(recovParms$zetaDeltaMat[,1],recovParms$zetaDeltaMat[,2],recovParms$parmRange,rescaleParms=rescaleParms,confPts=NULL,confPtsCol="darkslategrey",targetVals=tvals,targetPch=tpch,taus=taus,cW=pObj$sigs[2,1],cB=pObj$sigs[2,2],cex=lcex))
  dev.off()
}
```

## Replicate Danger Zones Plots from Obs. Studies (2018) paper

```{r 3}
require(lattice)
#used to generate figure 1 in the Observational Studies paper

#set up a grid
N <- 201
lbd <- -4; ubd <- 4
#set grid values
zeta <- seq(lbd,ubd,length=N)
delta <- seq(lbd,ubd,length=N)

#functions that compute absolute bias differences for different estimators
betMwin <- function(zeta,delta,cB=1,cW=1) {abs(delta/cB)-abs(zeta/cW)}
olsMwin <- function(zeta,delta,cB=1,cW=1) {abs((zeta+delta)/(cW+cB))-abs(zeta/cW)}
glsMwin <- function(zeta,delta,cB=1,cW=1,lambda=.5) {abs((zeta+lambda*delta)/(cW+lambda*cB))-abs(zeta/cW)}

winBias <- function(zeta,delta,cB=1,cW=1) {zeta/cW}
betBias <- function(zeta,delta,cB=1,cW=1) {delta/cB}
olsBias <- function(zeta,delta,cB=1,cW=1) {(zeta+delta)/(cW+cB)}
glsBias <- function(zeta,delta,cB=1,cW=1,lambda=.5) {(zeta+lambda*delta)/(cW+lambda*cB)}

#choose the comparison here: betMwin or olsMwin or glsMwin
#one can even plot abs bias for a single estimator, of course, as these are also defined above.
compFUN <- "olsMwin"

bd.1.1 <-outer(zeta,delta,FUN=compFUN,cB=2,cW=2)
bd.1.3 <-outer(zeta,delta,FUN=compFUN,cB=1,cW=3)
bd.3.1 <-outer(zeta,delta,FUN=compFUN,cB=3,cW=1)

#helper for lattice levelplot: x & y axis lines only
pfunct = function(x, y, z,...) {
  panel.levelplot(x, y, z,...)
  panel.abline(h=0,col.line=8)
  panel.abline(v=0,col.line=8)
}

#same helper, with y=x line added.
pfunct11 = function(x, y, z,...) {
    panel.levelplot(x, y, z,...)
    panel.abline(h=0,col.line=8)
    panel.abline(v=0,col.line=8)
    panel.abline(a=0,b=1,col.line=1)
}

#set up for legend
at.pts <- seq(-4,4,length=9)
spec.lbl <- as.character(at.pts)
spec.lbl[1] <- "OLS\nbetter"
spec.lbl[length(spec.lbl)] <- "Within\nbetter"

lcex <- 2.5
png("dz_1_1.png",width=480*2,height=480*2)
plot(levelplot(t(bd.1.1), at=seq(-4,4,length=17),colorkey=list(at=at.pts,labels=list(labels=spec.lbl,cex=lcex)),scales=list(x=list(cex=lcex),y=list(cex=lcex)),panel=pfunct11,row.values=zeta,column.values=delta,xlab=list(expression(delta^{yz}),cex=lcex),ylab=list(expression(zeta^{yz}),cex=lcex)))
dev.off()
png("dz_1_3.png",width=480*2,height=480*2)
plot(levelplot(t(bd.1.3), at=seq(-4,4,length=17),colorkey=list(at=at.pts,labels=list(labels=spec.lbl,cex=lcex)),scales=list(x=list(cex=lcex),y=list(cex=lcex)),panel=pfunct,row.values=zeta,column.values=delta,xlab=list(expression(delta^{yz}),cex=lcex),ylab=list(expression(zeta^{yz}),cex=lcex)))
dev.off()
png("dz_3_1.png",width=480*2,height=480*2)
plot(levelplot(t(bd.3.1), at=seq(-4,4,length=17),colorkey=list(at=at.pts,labels=list(labels=spec.lbl,cex=lcex)),scales=list(x=list(cex=lcex),y=list(cex=lcex)),panel=pfunct,row.values=zeta,column.values=delta,xlab=list(expression(delta^{yz}),cex=lcex),ylab=list(expression(zeta^{yz}),cex=lcex)))
dev.off()
```

Done.